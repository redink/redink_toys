<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>./c23.COVER.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/redink/github/sort_erlang/suanfa/c23.erl by COVER 2016-05-26 at 23:46:58

****************************************************************************

        |  -module(c23).
        |  
        |  % -export([mergesort/1]).
        |  -export([start/0]).
        |  -export([swim/1, sink/1]).
        |  -export([heapsort/1]).
        |  
        |  % mergesort(L) when erlang:length(L) =&lt; 1 -&gt; L;
        |  % mergesort(L) when erlang:length(L) =&lt; 15 -&gt;
        |  % 	c2:insertsort(L);
        |  % mergesort(L) -&gt;
        |  % 	{L1, L2} = lists:split(erlang:round(erlang:length(L)/2), L),
        |  % 	merge(mergesort(L1), mergesort(L2), []).
        |  
        |  % merge([], L2, Res) -&gt; lists:reverse(Res) ++ L2;
        |  % merge(L1, [], Res) -&gt; lists:reverse(Res) ++ L1;
        |  % merge([H1 | T1], [H2 | T2], Res) when H1 &lt; H2 -&gt;
        |  % 	merge(T1, [H2 | T2], [H1 | Res]);
        |  % merge([H1 | T1], [H2 | T2], Res) -&gt;
        |  % 	merge([H1 | T1], T2, [H2 | Res]).
        |  
        |  
<font color=red>     0..|  heapsort(L) when erlang:length(L) =&lt; 1 -&gt; L;</font>
        |  heapsort(L) -&gt;
     1..|  	heapsort(L, []).
        |  
        |  heapsort([], Res) -&gt;
     1..|  	Res;
        |  heapsort(L, Res) -&gt;
     5..|  	[H | T] = swim(L),
     5..|  	heapsort(T, [H | Res]).
        |  
        |  start() -&gt;
<font color=red>     0..|  	List1 = swim([0]),</font>
<font color=red>     0..|  	List1 = sink([0]),</font>
        |  
<font color=red>     0..|  	[H2 | _] = List2 = swim(List1 ++ [1]),</font>
<font color=red>     0..|  	[H2 | _] = sink([1 | List1]),</font>
        |  
<font color=red>     0..|  	[H3 | _] = List3 = swim(List2 ++ [2]),</font>
<font color=red>     0..|  	[H3 | _] = sink([2 | List2]),</font>
        |  
<font color=red>     0..|  	[H4 | _] = List4 = swim(List3 ++ [3]),</font>
<font color=red>     0..|  	[H4 | _] = sink([3 | List3]),</font>
        |  
<font color=red>     0..|  	[H5 | _] = List5 = swim(List4 ++ [4]),</font>
<font color=red>     0..|  	[H5 | _] = sink([4 | List4]),</font>
        |  
<font color=red>     0..|  	List5.</font>
        |  
        |  swim(List) -&gt;
     5..|  	LLen = erlang:length(List),
     5..|  	swim(List, LLen).
        |  
        |  swim(List, K) when K &gt; 1 -&gt;
     5..|  	case nth(K, List) &gt; nth(K div 2, List) of
        |  		true -&gt;
     2..|  			swim(exch(List, K div 2, K), K div 2);
        |  		_ -&gt;
     3..|  			List
        |  	end;
        |  swim(List, _K) -&gt;
     2..|  	List.
        |  
        |  sink(List) -&gt;
<font color=red>     0..|  	LLen = erlang:length(List),</font>
<font color=red>     0..|  	sink(List, 1, LLen).</font>
        |  
        |  sink(List, K, LLen) when K &lt; LLen -&gt;
<font color=red>     0..|  	case nth(K, List) &lt; nth(2 * K, List) of</font>
        |  		true -&gt;
<font color=red>     0..|  			sink(exch(List, K, 2 * K), K * 2, LLen);</font>
        |  		_ -&gt;
<font color=red>     0..|  			List</font>
        |  	end;
        |  sink(List, _, _) -&gt;
<font color=red>     0..|  	List.</font>
        |  
        |  exch(L, I, J) when I == J -&gt;
<font color=red>     0..|      L;</font>
        |  exch(L, I, J) when I &gt; J -&gt;
<font color=red>     0..|      exch(L, J, I);</font>
        |  exch(L, I, J) when I &lt; J -&gt;
     2..|      case erlang:length(L) &gt;= J of
        |          true -&gt;
     2..|              exch(L, I, J, 1, [], [], [], 0, 0);
        |          _ -&gt;
<font color=red>     0..|              error</font>
        |      end.
        |  
        |  exch([], _, _, _, Res1, Res2, Res3, II, JJ) -&gt;
     2..|      lists:reverse(Res3 ++ [II] ++ Res2 ++ [JJ] ++ Res1);
        |  exch([H | T], I, J, Index, Res1, Res2, Res3, II, JJ) -&gt;
     6..|      if
        |          I &gt; Index -&gt;
     1..|              exch(T, I, J, Index + 1, [H | Res1], Res2, Res3, II, JJ);
        |          I == Index -&gt;
     2..|              exch(T, I, J, Index + 1, Res1, Res2, Res3, H, JJ);
        |          I &lt; Index andalso J &gt; Index -&gt;
     1..|              exch(T, I, J, Index + 1, Res1, [H | Res2], Res3, II, JJ);
        |          J == Index -&gt;
     2..|              exch(T, I, J, Index + 1, Res1, Res2, Res3, II, H);
        |          J &lt; Index -&gt;
<font color=red>     0..|              exch(T, I, J, Index + 1, Res1, Res2, [H | Res3], II, JJ)</font>
        |      end.
        |  
        |  nth(N, L) -&gt;
    10..|      nth(L, N, 1).
        |  
        |  nth([], _, _) -&gt;
<font color=red>     0..|      erlang:throw(error);</font>
        |  nth([H | _], N, Index) when N == Index -&gt;
    10..|      H;
        |  nth([_ | T], N, Index) -&gt;
    13..|      nth(T, N, Index + 1).
</pre>
</body>
</html>
